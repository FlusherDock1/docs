# Widgets

Widgets are self-contained blocks of functionality that solve different tasks. Widgets always have a user interface and a backend controller (the widget class) that prepares the widget data and handles AJAX requests generated by the widget user interface.

## Generic Widgets

Widgets are the backend equivalent of front-end [Components](../cms/components.md). They are similar because they are modular bundles of functionality, supply partials and are named using aliases. The key difference is that backend widgets use YAML markup for their configuration and bind themselves to Backend pages.

Widget classes reside inside the **widgets** directory of the plugin directory. The inner directory name matches the name of the widget class written in lowercase. Widgets can supply assets and partials. An example widget directory structure looks like this:

::: dir
├── `widgets`
|   ├── form
|   |   ├── partials
|   |   |   └── _form.htm _<== Partial File_
|   |   └── assets
|   |       ├── js
|   |       |   └── form.js _<== JavaScript File_
|   |       └── css
|   |           └── form.css _<== StyleSheet File_
|   └── Form.php _<== Widget Class_
:::

### Class Definition

The generic widget classes must extend the `Backend\Classes\WidgetBase` class. As any other plugin class, generic widget controllers should belong to the [plugin namespace](../plugin/registration.md#oc-plugin-namespaces). Example widget controller class definition:

```php
namespace Backend\Widgets;

use Backend\Classes\WidgetBase;

class Lists extends WidgetBase
{
    /**
     * @var string A unique alias to identify this widget.
     */
    protected $defaultAlias = 'list';

    // ...
}
```

The widget class must contain a **render()** method for producing the widget markup by rendering a widget partial. Example:

```php
public function render()
{
    return $this->makePartial('list');
}
```

To pass variables to partials you can either add them to the `$vars` property.

```php
public function render()
{
    $this->vars['var'] = 'value';

    return $this->makePartial('list');
}
```

Alternatively you may pass the variables to the second parameter of the makePartial() method:

```php
public function render()
{
    return $this->makePartial('list', ['var' => 'value']);
}
```

<a id="oc-ajax-handlers"></a>
### AJAX Handlers

Widgets implement the same AJAX approach as the [backend controllers](controllers-ajax#oc-ajax). The AJAX handlers are public methods of the widget class with names starting with the **on** prefix. The only difference between the widget AJAX handlers and backend controller's AJAX handlers is that you should use the widget's `getEventHandler` method to return the widget's handler name when you refer to it in the widget partials.

```php
<a
    href="javascript:;"
    data-request="<?= $this->getEventHandler('onPaginate') ?>"
    title="Next page">Next</a>
```

When called from a widget class or partial the AJAX handler will target itself. For example, if the widget uses the alias of **mywidget** the handler will be targeted with `mywidget::onName`. The above would output the following attribute value:

```html
data-request="mywidget::onPaginate"
```

### Binding Widgets to Controllers

A widget should be bound to a [backend controller](controllers-ajax) before you can start using it in a backend page or partial. Use the widget's `bindToController` method for binding it to a controller. The best place to initialize a widget is the controller's constructor. Example:

```php
public function __construct()
{
    parent::__construct();

    $myWidget = new MyWidgetClass($this);
    $myWidget->alias = 'myWidget';
    $myWidget->bindToController();
}
```

After binding the widget you can access it in the controller's view or partial by its alias:

```php
<?= $this->widget->myWidget->render() ?>
```
